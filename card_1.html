<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–£—á–∏–º –Ω–µ–º–µ—Ü–∫–∏–π Pro</title>
    <style>
        :root {
            --primary-color: #007bff; /* –°–∏–Ω–∏–π */
            --secondary-color: #6c757d; /* –°–µ—Ä—ã–π */
            --success-color: #28a745; /* –ó–µ–ª–µ–Ω—ã–π */
            --danger-color: #dc3545; /* –ö—Ä–∞—Å–Ω—ã–π */
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --card-german-bg: #5dade2;
            --card-russian-bg: #f7dc6f;
            --border-radius: 8px;
        }

        body {
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background-color: var(--light-color);
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: var(--dark-color);
            transition: background-color 0.3s;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 900px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .score-board {
            background-color: #fff;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-size: 1em;
        }
        #scoreCorrect { color: var(--success-color); font-weight: bold; }
        #scoreIncorrect { color: var(--danger-color); font-weight: bold; }

        .button {
            padding: 10px 18px;
            font-size: 1em;
            color: white;
            background-color: var(--primary-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
        }
        .button:hover {
            background-color: #0056b3;
        }
        .button:active {
            transform: scale(0.98);
        }
        #nextButton {
            background-color: var(--success-color);
        }
        #nextButton:hover {
            background-color: #1e7e34;
        }
        #resetProgressButton {
            background-color: var(--danger-color);
        }
        #resetProgressButton:hover {
            background-color: #c82333;
        }


        h1 {
            color: var(--dark-color);
            margin-bottom: 25px;
        }

        .flashcard-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            width: 100%;
            max-width: 900px; /* Default PC max width */
            margin-bottom: 30px;
        }

        .flashcard {
            min-width: 150px; /* Min width for PC */
            height: 100px;    /* Default height for PC */
            background-color: #fff;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            perspective: 1000px;
            display: flex;
            text-align: center;
            padding: 0; /* Padding handled by inner content */
            box-sizing: border-box;
            position: relative; /* For answer buttons positioning */
        }

        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.7s;
            transform-style: preserve-3d;
            border-radius: var(--border-radius); /* Ensure inner also has radius */
        }

        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }

        .flashcard-front,
        .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column; /* Allow for word and buttons */
            justify-content: center;
            align-items: center;
            font-size: 1.1em;
            padding: 10px;
            box-sizing: border-box;
            border-radius: var(--border-radius);
        }

        .flashcard-front {
            background-color: var(--card-german-bg);
            color: white;
        }

        .flashcard-back {
            background-color: var(--card-russian-bg);
            color: var(--dark-color);
            transform: rotateY(180deg);
        }
        .word-text {
            margin-bottom: auto; /* Pushes buttons down if they are below */
            padding-top: 10px; /* Give some space at top */
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .answer-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px; /* Space between word and buttons */
            padding-bottom: 5px;
        }

        .answer-buttons button {
            padding: 6px 10px;
            font-size: 0.8em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: white;
        }
        .answer-buttons .correct-btn { background-color: var(--success-color); }
        .answer-buttons .incorrect-btn { background-color: var(--danger-color); }
        .answer-buttons button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
        }
        .answered-correct .flashcard-inner { border: 3px solid var(--success-color); }
        .answered-incorrect .flashcard-inner { border: 3px solid var(--danger-color); }


        /* Mobile View Specifics */
        body.mobile-view .flashcard-container {
            max-width: 450px; /* Narrower container for mobile */
        }
        body.mobile-view .flashcard {
            width: calc(50% - 10px); /* 2 cards per row */
            height: 150px; /* Taller cards for mobile */
            min-width: 0; /* Override PC min-width */
        }
         body.mobile-view .flashcard-front,
         body.mobile-view .flashcard-back {
            font-size: 1em; /* Adjust font for smaller cards if needed */
        }

        /* PC View (Default, can be overridden if body doesn't have .mobile-view) */
        /* Assuming 5 cards per row for PC by default if container is wide enough */
        .flashcard {
             flex: 1 1 150px; /* Allow cards to grow and shrink, base of 150px */
        }


        @media (max-width: 600px) { /* Automatic mobile styles for small screens */
            body:not(.pc-view-forced) { /* Apply mobile styles unless PC view is forced */
                /* Simulating some mobile-view defaults for smaller screens */
            }
            body:not(.pc-view-forced) .flashcard-container {
                max-width: 100%;
            }
             body:not(.pc-view-forced) .flashcard {
                width: calc(50% - 10px);
                height: 140px;
            }
             body:not(.pc-view-forced) .controls {
                flex-direction: column;
                align-items: stretch;
            }
            body:not(.pc-view-forced) .button {
                width: 100%;
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body class="pc-view"> <h1>–£—á–∏–º –Ω–µ–º–µ—Ü–∫–∏–π üá©üá™üá∑üá∫</h1>

    <div class="controls">
        <div class="score-board">
            –ü—Ä–∞–≤–∏–ª—å–Ω–æ: <span id="scoreCorrect">0</span> |
            –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ: <span id="scoreIncorrect">0</span>
        </div>
        <div>
            <button class="button" id="viewToggleButton">üì± –ú–æ–±–∏–ª—å–Ω—ã–π –≤–∏–¥</button>
            <button class="button" id="resetProgressButton" title="–°–±—Ä–æ—Å–∏—Ç—å –≤–µ—Å—å –ø—Ä–æ–≥—Ä–µ—Å—Å (—Å—á–µ—Ç –∏ –≤—ã—É—á–µ–Ω–Ω—ã–µ —Å–ª–æ–≤–∞)">üîÑ –°–±—Ä–æ—Å</button>
        </div>
    </div>

    <div class="flashcard-container" id="flashcardContainer">
        </div>

    <button class="button" id="nextButton">–°–ª–µ–¥—É—é—â–∏–µ —Å–ª–æ–≤–∞ ‚û°Ô∏è</button>

    <script>
        const flashcardContainer = document.getElementById('flashcardContainer');
        const nextButton = document.getElementById('nextButton');
        const viewToggleButton = document.getElementById('viewToggleButton');
        const resetProgressButton = document.getElementById('resetProgressButton');
        const scoreCorrectEl = document.getElementById('scoreCorrect');
        const scoreIncorrectEl = document.getElementById('scoreIncorrect');

        let allWords = [];
        let currentWords = []; // Words currently displayed
        let cardsPerPagePC = 15; // e.g., 3 rows of 5
        let cardsPerPageMobile = 6; // e.g., 3 rows of 2
        let currentCardsPerPage = cardsPerPagePC;

        let currentPage = 0;
        let correctCount = 0;
        let incorrectCount = 0;
        let wordStatus = {}; // { wordId: 'correct' | 'incorrect' }

        // --- LocalStorage Keys ---
        const LS_CURRENT_PAGE = 'germanFlash_currentPage';
        const LS_CORRECT_COUNT = 'germanFlash_correctCount';
        const LS_INCORRECT_COUNT = 'germanFlash_incorrectCount';
        const LS_WORD_STATUS = 'germanFlash_wordStatus';
        const LS_VIEW_MODE = 'germanFlash_viewMode'; // 'pc' or 'mobile'

        function loadProgress() {
            currentPage = parseInt(localStorage.getItem(LS_CURRENT_PAGE)) || 0;
            correctCount = parseInt(localStorage.getItem(LS_CORRECT_COUNT)) || 0;
            incorrectCount = parseInt(localStorage.getItem(LS_INCORRECT_COUNT)) || 0;
            wordStatus = JSON.parse(localStorage.getItem(LS_WORD_STATUS)) || {};
            const savedView = localStorage.getItem(LS_VIEW_MODE);

            if (savedView === 'mobile') {
                document.body.classList.remove('pc-view');
                document.body.classList.add('mobile-view');
                viewToggleButton.textContent = 'üíª –ü–ö –≤–∏–¥';
                currentCardsPerPage = cardsPerPageMobile;
            } else {
                document.body.classList.remove('mobile-view');
                document.body.classList.add('pc-view');
                viewToggleButton.textContent = 'üì± –ú–æ–±–∏–ª—å–Ω—ã–π –≤–∏–¥';
                currentCardsPerPage = cardsPerPagePC;
            }
            updateScoreDisplay();
        }

        function saveProgress() {
            localStorage.setItem(LS_CURRENT_PAGE, currentPage);
            localStorage.setItem(LS_CORRECT_COUNT, correctCount);
            localStorage.setItem(LS_INCORRECT_COUNT, incorrectCount);
            localStorage.setItem(LS_WORD_STATUS, JSON.stringify(wordStatus));
            localStorage.setItem(LS_VIEW_MODE, document.body.classList.contains('mobile-view') ? 'mobile' : 'pc');
        }

        function updateScoreDisplay() {
            scoreCorrectEl.textContent = correctCount;
            scoreIncorrectEl.textContent = incorrectCount;
        }

        function createCard(wordData) {
            const card = document.createElement('div');
            card.classList.add('flashcard');
            card.dataset.id = wordData.id;

            const inner = document.createElement('div');
            inner.classList.add('flashcard-inner');

            const front = document.createElement('div');
            front.classList.add('flashcard-front');
            const frontText = document.createElement('span');
            frontText.classList.add('word-text');
            frontText.textContent = wordData.german;
            front.appendChild(frontText);


            const back = document.createElement('div');
            back.classList.add('flashcard-back');
            const backText = document.createElement('span');
            backText.classList.add('word-text');
            backText.textContent = wordData.russian;
            back.appendChild(backText);

            const answerButtonsDiv = document.createElement('div');
            answerButtonsDiv.classList.add('answer-buttons');

            const correctBtn = document.createElement('button');
            correctBtn.classList.add('correct-btn');
            correctBtn.textContent = '‚úÖ –ó–Ω–∞–ª';
            correctBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent card flip
                markAnswer(wordData.id, true, card);
            };

            const incorrectBtn = document.createElement('button');
            incorrectBtn.classList.add('incorrect-btn');
            incorrectBtn.textContent = '‚ùå –ù–µ –∑–Ω–∞–ª';
            incorrectBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent card flip
                markAnswer(wordData.id, false, card);
            };

            answerButtonsDiv.appendChild(correctBtn);
            answerButtonsDiv.appendChild(incorrectBtn);
            back.appendChild(answerButtonsDiv);

            // Apply existing status
            if (wordStatus[wordData.id]) {
                card.classList.add(wordStatus[wordData.id] === 'correct' ? 'answered-correct' : 'answered-incorrect');
                correctBtn.disabled = true;
                incorrectBtn.disabled = true;
            }


            inner.appendChild(front);
            inner.appendChild(back);
            card.appendChild(inner);

            card.addEventListener('click', () => {
                if (!event.target.closest('.answer-buttons')) { // Don't flip if answer button was clicked
                     card.classList.toggle('flipped');
                }
            });

            return card;
        }

        function markAnswer(wordId, isCorrect, cardElement) {
            if (wordStatus[wordId]) return; // Already answered

            wordStatus[wordId] = isCorrect ? 'correct' : 'incorrect';
            if (isCorrect) {
                correctCount++;
                cardElement.classList.add('answered-correct');
            } else {
                incorrectCount++;
                cardElement.classList.add('answered-incorrect');
            }

            // Disable buttons on this card
            const buttons = cardElement.querySelectorAll('.answer-buttons button');
            buttons.forEach(btn => btn.disabled = true);

            updateScoreDisplay();
            saveProgress();
        }

        function displayWords() {
            flashcardContainer.innerHTML = '';
            const startIndex = currentPage * currentCardsPerPage;
            // Ensure we don't go past the end of the words array
            const endIndex = Math.min(startIndex + currentCardsPerPage, allWords.length);

            currentWords = allWords.slice(startIndex, endIndex);

            if (currentWords.length === 0 && currentPage > 0 && allWords.length > 0) {
                // If we are on a page that's now empty (e.g. after view switch or list end)
                currentPage = 0; // Go to first page
                saveProgress();
                displayWords(); // Recursive call, be careful
                return;
            } else if (currentWords.length === 0 && allWords.length === 0) {
                 flashcardContainer.textContent = "–°–ª–æ–≤–∞ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–∞–π–ª words.json.";
                 return;
            } else if (currentWords.length === 0 && allWords.length > 0) {
                // This case means we cycled past the end and currentPage is already 0, but slice is empty.
                // This shouldn't happen if the above logic is correct for cycling.
                // But as a fallback:
                 flashcardContainer.textContent = "–ë–æ–ª—å—à–µ –Ω–µ—Ç —Å–ª–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ.";
                 return;
            }


            currentWords.forEach(word => {
                const cardElement = createCard(word);
                flashcardContainer.appendChild(cardElement);
            });
             // Adjust currentPage if it's out of bounds due to word list length
            const maxPage = Math.max(0, Math.ceil(allWords.length / currentCardsPerPage) - 1);
            if (currentPage > maxPage) {
                currentPage = maxPage;
                saveProgress();
                // No redisplay here, it will be handled by next click or view switch
            }
        }

        nextButton.addEventListener('click', () => {
            const maxPage = Math.ceil(allWords.length / currentCardsPerPage) - 1;
            if (currentPage < maxPage) {
                currentPage++;
            } else {
                currentPage = 0; // Loop back to the beginning
            }
            saveProgress();
            displayWords();
        });

        viewToggleButton.addEventListener('click', () => {
            document.body.classList.toggle('mobile-view');
            document.body.classList.toggle('pc-view');

            if (document.body.classList.contains('mobile-view')) {
                currentCardsPerPage = cardsPerPageMobile;
                viewToggleButton.textContent = 'üíª –ü–ö –≤–∏–¥';
            } else {
                currentCardsPerPage = cardsPerPagePC;
                viewToggleButton.textContent = 'üì± –ú–æ–±–∏–ª—å–Ω—ã–π –≤–∏–¥';
            }
            // Recalculate current page to keep roughly the same words in view or reset
            // For simplicity, we can try to maintain the first word's index.
            const firstWordIndexOfCurrentPage = currentPage * (document.body.classList.contains('mobile-view') ? cardsPerPagePC : cardsPerPageMobile);
            currentPage = Math.floor(firstWordIndexOfCurrentPage / currentCardsPerPage);

            const maxPage = Math.max(0, Math.ceil(allWords.length / currentCardsPerPage) - 1);
            if(currentPage > maxPage) currentPage = maxPage;


            saveProgress();
            displayWords();
        });

        resetProgressButton.addEventListener('click', () => {
            if (confirm("–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å –≤–µ—Å—å –ø—Ä–æ–≥—Ä–µ—Å—Å? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.")) {
                localStorage.removeItem(LS_CURRENT_PAGE);
                localStorage.removeItem(LS_CORRECT_COUNT);
                localStorage.removeItem(LS_INCORRECT_COUNT);
                localStorage.removeItem(LS_WORD_STATUS);
                // Keep view mode or reset it too? Let's reset it.
                localStorage.removeItem(LS_VIEW_MODE);


                currentPage = 0;
                correctCount = 0;
                incorrectCount = 0;
                wordStatus = {};

                // Reset view to default (PC)
                document.body.classList.remove('mobile-view');
                document.body.classList.add('pc-view');
                viewToggleButton.textContent = 'üì± –ú–æ–±–∏–ª—å–Ω—ã–π –≤–∏–¥';
                currentCardsPerPage = cardsPerPagePC;


                updateScoreDisplay();
                // Re-apply status to any currently visible cards (which should be none after displayWords)
                // And reload words (or just redisplay them)
                displayWords(); // This will clear cards and redraw based on reset state
                console.log("–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–±—Ä–æ—à–µ–Ω.");
            }
        });


        async function fetchWords() {
            try {
                const response = await fetch('words.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                allWords = await response.json();
                if (!Array.isArray(allWords) || !allWords.every(w => w.id && w.german && w.russian)) {
                    console.error("–§–æ—Ä–º–∞—Ç words.json –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω.");
                    flashcardContainer.textContent = "–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ —Å–ª–æ–≤. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ words.json";
                    allWords = []; // Prevent further errors
                    return;
                }
                displayWords();
            } catch (error) {
                console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ª–æ–≤–∞:", error);
                flashcardContainer.textContent = "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ª–æ–≤–∞. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª words.json —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –¥–æ—Å—Ç—É–ø–µ–Ω.";
            }
        }

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            loadProgress(); // Load saved progress first
            fetchWords();   // Then fetch words and display
        });

    </script>

</body>
</html>